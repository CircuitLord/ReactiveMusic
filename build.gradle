plugins {
    id "fabric-loom" version "${loom_version}" apply false
}

ext {
    // Read active project and adapter from gradle.properties
    activeProject = findProperty("mochamix.project") ?: "mochamix"
    activeAdapter = findProperty("mochamix.adapter") ?: "v1_21_1"
    
    // Map adapter names to Minecraft version configurations
    minecraftTargets = [
        "v1_21_1": [
            minecraftVersion: "1.21.1",
            yarnMappings: "1.21.1+build.3",
            loaderVersion: "0.16.14",
            fabricApiVersion: "0.114.0+1.21.1",
            modMenuVersion: "11.0.3",
            yaclVersion: "3.6.2+1.21-fabric"
        ],
        "v1_21_5": [
            minecraftVersion: "1.21.5",
            yarnMappings: "1.21.5+build.1",
            loaderVersion: "0.17.1",
            fabricApiVersion: "0.127.0+1.21.5",
            modMenuVersion: "14.0.0-rc.2",
            yaclVersion: "3.7.0+1.21.5-fabric"
        ],
        "v1_20_4": [
            minecraftVersion: "1.20.4", 
            yarnMappings: "1.20.4+build.3",
            loaderVersion: "0.15.11",
            fabricApiVersion: "0.97.0+1.20.4",
            modMenuVersion: "11.0.3",
            yaclVersion: "3.6.2+1.21-fabric"
        ]
    ]
    
    activeConfig = minecraftTargets[activeAdapter]

    mod_version = [
        "mochamix": findProperty("mochamix_version"),
        "logical-loadouts": findProperty("logical_loadouts_version")
    ]
}

allprojects {
    group = maven_group
}

def activeProjectPath = ":projects:${activeProject}:${activeAdapter}"
def targetProject = findProject(activeProjectPath)

if (targetProject != null) {
    configure(targetProject) {
        apply plugin: "fabric-loom"
        apply plugin: "java"
        
        repositories {
            mavenCentral()
            maven { url "https://maven.fabricmc.net/" }
            maven { url "https://maven.terraformersmc.com/releases/" }
            maven { url "https://maven.isxander.dev/releases" }
        } 
        
        version = mod_version[activeProject]  + "+" + activeConfig.minecraftVersion
        base.archivesName = activeProject
        
        sourceSets {
            main {
                // Source directory precedence: adapter-specific FIRST, then common, then base version for overrides
                if (activeAdapter == "v1_21_5") {
                    // v1_21_5 overrides: v1_21_5 -> common -> v1_21_1 base
                    java.srcDirs = [
                        "src/main/java",                    // v1_21_5 adapter (highest precedence)
                        "../common/src/main/java",          // Common shared code (middle precedence)
                        "../v1_21_1/src/main/java"          // v1_21_1 base version (lowest precedence)
                    ]
                    resources.srcDirs = [
                        "src/main/resources", 
                        "../common/src/main/resources",
                        "../v1_21_1/src/main/resources"
                    ]
                } else {
                    // Base version (v1_21_1): adapter-specific + common
                    java.srcDirs = [
                        "src/main/java",                    // Adapter-specific code (highest precedence)
                        "../common/src/main/java"           // Common shared code (lower precedence)
                    ]
                    resources.srcDirs = [
                        "src/main/resources", 
                        "../common/src/main/resources"
                    ]
                }
            }
        }
        
        // For v1_21_5: Handle duplicate class files by creating a merged source tree
        if (activeAdapter == "v1_21_5") {
            def mergedSourceDir = file("${buildDir}/merged-sources/main/java")
            
            task mergeSources(type: Copy) {
                // Copy in reverse precedence order, so later copies overwrite earlier ones
                
                // First: Copy v1_21_1 base classes (lowest precedence)
                from "../v1_21_1/src/main/java"
                into mergedSourceDir
                
                // Second: Copy common classes (middle precedence)  
                from "../common/src/main/java"
                into mergedSourceDir
                duplicatesStrategy = DuplicatesStrategy.INCLUDE // Allow overwriting
                
                // Third: Copy v1_21_5 specific classes (highest precedence)
                from "src/main/java"  
                into mergedSourceDir
                duplicatesStrategy = DuplicatesStrategy.INCLUDE // Allow overwriting
            }
            
            // Update source sets to use merged directory
            sourceSets.main.java.srcDirs = [mergedSourceDir]
            
            // Ensure merge happens before compilation
            compileJava.dependsOn mergeSources
            
            // Also merge resources
            def mergedResourceDir = file("${buildDir}/merged-sources/main/resources")
            task mergeResources(type: Copy) {
                from "../v1_21_1/src/main/resources"
                from "../common/src/main/resources"
                from "src/main/resources"
                into mergedResourceDir
                duplicatesStrategy = DuplicatesStrategy.INCLUDE
            }
            
            sourceSets.main.resources.srcDirs = [mergedResourceDir]
            processResources.dependsOn mergeResources
            
            // Fix task dependencies for sourcesJar - do this after evaluation
            afterEvaluate {
                tasks.named('sourcesJar').configure {
                    dependsOn mergeSources, mergeResources
                }
            }
        }
        
        // Ensure compilation uses source directory priority order correctly
        tasks.withType(JavaCompile) {
            options.compilerArgs += ['-Xlint:-options']
            // Gradle should handle duplicate classes by source directory priority
        }
        
        dependencies {
            minecraft "com.mojang:minecraft:${activeConfig.minecraftVersion}"
            mappings "net.fabricmc:yarn:${activeConfig.yarnMappings}:v2"
            modImplementation "net.fabricmc:fabric-loader:${activeConfig.loaderVersion}"
            modImplementation "net.fabricmc.fabric-api:fabric-api:${activeConfig.fabricApiVersion}"
            modApi "com.terraformersmc:modmenu:${activeConfig.modMenuVersion}"
            modImplementation "dev.isxander:yet-another-config-lib:${activeConfig.yaclVersion}"
        }
        
        loom {
            mixin.defaultRefmapName = "reactivemusic.refmap.json"
            
            // Use organized nested run directories by client/server and version
            runConfigs {
                client {
                    // All projects using same adapter share: run/client/v1_21_1/, run/client/v1_21_5/, etc.
                    runDir = "../../../run/client/${activeAdapter}"
                    property 'fabric.username', 'Developer'
                }
                server {
                    // All projects using same adapter share: run/server/v1_21_1/, run/server/v1_21_5/, etc.
                    runDir = "../../../run/server/${activeAdapter}"
                }
            }
        }
        
        // Tasks to clear log directories, excluding latest.log
        task clearClientLogs(type: Delete) {
            def logsDir = file("../../../run/client/${activeAdapter}/logs")
            if (logsDir.exists() && logsDir.isDirectory()) {
                delete logsDir.listFiles().findAll { it.isFile() && it.name != "latest.log" }
            }
        }
        
        task clearServerLogs(type: Delete) {
            def logsDir = file("../../../run/server/${activeAdapter}/logs")
            if (logsDir.exists() && logsDir.isDirectory()) {
                delete logsDir.listFiles().findAll { it.isFile() && it.name != "latest.log" }
            }
        }
        
        task clearLogs {
            dependsOn clearClientLogs, clearServerLogs
        }
        
        java {
            toolchain.languageVersion = JavaLanguageVersion.of(21)
            withSourcesJar()
        }
        
        tasks.withType(JavaCompile) {
            options.release = 21
        }
    }
}

// Task to clear logs for all adapters, excluding latest.log
task clearAllLogs {
    doLast {
        minecraftTargets.keySet().each { adapter ->
            def clientLogsDir = file("run/client/${adapter}/logs")
            def serverLogsDir = file("run/server/${adapter}/logs")
            if (clientLogsDir.exists() && clientLogsDir.isDirectory()) {
                delete(clientLogsDir.listFiles().findAll { it.isFile() && it.name != "latest.log" })
            }
            if (serverLogsDir.exists() && serverLogsDir.isDirectory()) {
                delete(serverLogsDir.listFiles().findAll { it.isFile() && it.name != "latest.log" })
            }
        }
    }
}

// Task to diff source directories between two adapters, only for files in the latest adapter
task diffAdapters {
    def adapter1 = findProperty('adapter1') ?: 'v1_21_1'
    def adapter2 = findProperty('adapter2') ?: 'v1_21_5'
    def projectName = activeProject
    
    doFirst {
        println "Comparing files in projects/${projectName}/${adapter2}/src (latest adapter) with projects/${projectName}/${adapter1}/src"
    }
    
    doLast {
        def dir1 = file("projects/${projectName}/${adapter1}/src")
        def dir2 = file("projects/${projectName}/${adapter2}/src")
        
        fileTree(dir2).each { File file ->
            def relativePath = dir2.relativePath(file)
            def file1 = new File(dir1, relativePath)
            
            if (file1.exists()) {
                def path1 = file1.absolutePath?.replace('\\', '/')
                def path2 = file.absolutePath?.replace('\\', '/')
                if (path1 && path2) {
                    def command = ['git', 'diff', '--no-index', path1, path2]
                    def pb = new ProcessBuilder(command)
                    pb.redirectErrorStream(true)
                    def proc = pb.start()
                    proc.waitFor()
                    def output = proc.inputStream.text.trim()
                    if (!output.isEmpty()) {
                        // Open VSCode diff for this file
                        exec {
                            commandLine 'cmd', '/c', "code --diff \"${path1}\" \"${path2}\""
                            ignoreExitValue = true
                        }
                    }
                } else {
                    println "Skipping due to null path: path1=${path1}, path2=${path2}"
                }
            }
        }
    }
}

// Task to open VSCode diff viewer for the same file in two adapters
task diffFile {
    def filePath = findProperty('file') ?: 'main/java/com/example/Test.java'
    def adapter1 = findProperty('adapter1') ?: 'v1_21_1'
    def adapter2 = findProperty('adapter2') ?: 'v1_21_5'
    def projectName = activeProject
    
    doLast {
        def file1 = file("projects/${projectName}/${adapter1}/src/${filePath}")
        def file2 = file("projects/${projectName}/${adapter2}/src/${filePath}")
        
        if (file1.exists() && file2.exists()) {
            def path1 = file1.absolutePath
            def path2 = file2.absolutePath
            println "Opening VSCode diff for ${filePath} between ${adapter1} and ${adapter2}"
            exec {
                commandLine 'cmd', '/c', "code --diff \"${path1}\" \"${path2}\""
                ignoreExitValue = true
            }
        } else {
            println "File ${filePath} does not exist in both adapters: ${adapter1} (${file1.exists()}), ${adapter2} (${file2.exists()})"
        }
    }
}
